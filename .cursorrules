# Cursor AI Development Documentation

## Project Overview
This is a podcast generation app that automatically creates podcast episodes from news sources using AI summarization and text-to-speech. The app is built with a component-first development approach optimized for AI agent collaboration, using Bun for enhanced development speed.

## Current Codebase Structure

**IMPORTANT: Always update this structure when creating/modifying files or folders**

```
morning-pod/
├── .cursorrules                    # AI development rules and workflow
├── .husky/                         # Git hooks for code quality
├── .nvmrc                          # Node.js version (22)
├── bun.config.ts                   # Bun configuration
├── bun.lockb                       # Bun lockfile
├── eslint.config.mjs               # ESLint configuration
├── next.config.ts                  # Next.js configuration
├── package.json                    # Dependencies and scripts
├── postcss.config.mjs              # PostCSS configuration
├── .prettierrc & .prettierignore   # Code formatting config
├── tsconfig.json                   # TypeScript configuration
├── README.md                       # Project documentation
├── public/                         # Static assets
├── scripts/                        # Build and utility scripts
├── tests/                          # Test files
├── drizzle/                        # Database migrations
└── src/
    ├── app/                        # Next.js App Router
    │   ├── globals.css             # Global styles + daisyUI config
    │   ├── layout.tsx              # Root layout with tRPC provider
    │   ├── page.tsx                # Homepage dashboard
    │   ├── favicon.ico             # App icon
    │   ├── api/                    # API routes
    │   │   └── trpc/[trpc]/route.ts # tRPC API handler
    │   ├── episodes/               # Episode pages
    │   │   ├── page.tsx            # Episodes listing page
    │   │   ├── demo/               # Demo episode page
    │   │   │   └── page.tsx
    │   │   └── comparison/         # Component variant comparison
    │   │       └── page.tsx        # Episode card variants showcase
    │   ├── sources/                # Sources management
    │   │   └── page.tsx            # Sources management page
    │   ├── queue/                  # Queue management
    │   │   ├── page.tsx            # Queue status page
    │   │   └── comparison/         # Queue variants comparison
    │   │       └── page.tsx        # Queue status variants showcase
    │   ├── internal/               # Development hub
    │   │   └── page.tsx            # Component development overview
    │   └── players/                # Player comparison pages
    │       └── comparison/         # Player variants comparison
    │           └── page.tsx        # Episode player variants showcase
    ├── components/
    │   ├── ui/                     # Base UI components
    │   │   ├── index.ts            # Component exports
    │   │   ├── button.tsx          # Button component
    │   │   ├── dialog.tsx          # Dialog/Modal component
    │   │   ├── progress.tsx        # Progress bar component
    │   │   ├── select.tsx          # Select dropdown component
    │   │   ├── slider.tsx          # Slider component
    │   │   ├── theme-switcher.tsx  # Theme selection component (forest default)
    │   │   └── toast.tsx           # Toast notifications
    │   ├── layouts/                # Page layouts
    │   │   ├── index.ts            # Layout exports
    │   │   ├── main-layout.tsx     # Main app layout with sidebar nav
    │   │   └── player-layout.tsx   # Episode player layout
    │   ├── features/               # App-specific components
    │   │   └── api-test.tsx        # API connection test component
    │   └── internal/               # Internal development components
    │       ├── variants/           # Component variants
    │       │   ├── index.ts        # Variant exports
    │       │   ├── episode-card-v1.tsx # Minimal episode card
    │       │   ├── episode-card-v2.tsx # Visual episode card
    │       │   ├── episode-card-v3.tsx # Compact episode card
    │       │   ├── episode-player-v1.tsx # Traditional audio player
    │       │   ├── episode-player-v2.tsx # Spotify-inspired player
    │       │   ├── episode-player-v3.tsx # Minimalist waveform player
    │       │   ├── queue-status-v1.tsx # Progress bar layout
    │       │   ├── queue-status-v2.tsx # Real-time dashboard
    │       │   └── queue-status-v3.tsx # Timeline visualization
    │       └── comparisons/        # Component comparison pages (future)
    ├── lib/
    │   ├── utils.ts                # Utility functions
    │   ├── db/                     # Database schema & connection
    │   │   ├── schema.ts           # Drizzle schema definitions
    │   │   └── connection.ts       # Database connection
    │   ├── trpc/                   # API layer
    │   │   ├── client.ts           # tRPC client configuration
    │   │   ├── server.ts           # tRPC server configuration
    │   │   ├── server-mock.ts      # Mock server for development
    │   │   ├── provider.tsx        # React Query provider
    │   │   ├── root.ts             # Main router (production)
    │   │   ├── root-mock.ts        # Mock router (development)
    │   │   └── routers/            # Individual routers
    │   │       ├── episodes.ts     # Episodes API
    │   │       ├── episodes-mock.ts # Episodes mock API
    │   │       ├── sources.ts      # Sources API
    │   │       ├── sources-mock.ts # Sources mock API
    │   │       ├── queue.ts        # Queue API
    │   │       └── queue-mock.ts   # Queue mock API
    │   ├── mock-data/              # Development mock data
    │   │   ├── index.ts            # Mock data exports
    │   │   ├── episodes.ts         # Episode mock data and interfaces
    │   │   ├── sources.ts          # Sources mock data
    │   │   └── queue.ts            # Queue mock data
    │   ├── schemas/                # Zod validation schemas (future)
    │   ├── services/               # Business logic services (future)
    │   └── utils/                  # Additional utilities (future)
    └── types/                      # TypeScript type definitions (future)
```

**File Update Rule**: Whenever you create, modify, delete, or move files/folders, immediately update this structure in the cursor rules. This helps maintain accurate project navigation and prevents getting lost in the codebase.

## Core Development Principles

### 1. Component-First Development with Variants
- **Always start with UI components** before backend logic
- **Build multiple versions** of key components (2-3 variants) for comparison
- Build components with mock data first
- Use TypeScript interfaces for all props
- Create reusable, composable components
- Test components in isolation
- Select best designs through iteration and testing

### 2. Technology Stack Standards

#### Frontend
- **Next.js 15** with App Router and TypeScript
- **Tailwind CSS 4** for styling
- **DaisyUI** for component primitives
- **Radix UI** for advanced interactive components
- **Framer Motion** for animations
- **Lucide React** for icons
- **Bun** for package management, runtime, and testing

#### Backend
- **tRPC** for type-safe APIs
- **Drizzle ORM** with Vercel Postgres
- **Zod 4** for schema validation
- **OpenAI and Claude** for AI services
- **Vercel Blob** for file storage

### 3. File Structure Convention
```
/components
  /ui          # Base components (Button, Input, etc.)
  /features    # App-specific components
  /variants    # Multiple versions of key components
    /episode-card-v1.tsx
    /episode-card-v2.tsx
    /episode-card-v3.tsx
  /layouts     # Page layouts
/lib
  /trpc        # API layer
  /db          # Database schema and connection
  /services    # Business logic
  /utils       # Utility functions
  /mock-data   # Development mock data
/types         # TypeScript type definitions
/app           # Next.js app router pages
```

## Development Guidelines

### Component Creation with Variants
1. **Start with TypeScript interface**:
```tsx
interface EpisodePlayerProps {
  episode: Episode;
  isLoading?: boolean;
  onPlay?: () => void;
  variant?: 'minimal' | 'detailed' | 'compact';
}
```

2. **Create multiple versions for key components**:
```tsx
// components/variants/episode-card-v1.tsx - Minimal version
export function EpisodeCardV1({ episode }: EpisodeCardProps) {
  return (
    <div className="card bg-base-100 shadow-sm border-0">
      <div className="card-body p-4">
        <h3 className="card-title text-sm font-medium">{episode.title}</h3>
        <p className="text-xs text-base-content/70 line-clamp-2">{episode.summary}</p>
      </div>
    </div>
  );
}

// components/variants/episode-card-v2.tsx - Visual-heavy version
export function EpisodeCardV2({ episode }: EpisodeCardProps) {
  return (
    <div className="card bg-gradient-to-br from-base-100 to-base-200 shadow-lg">
      <div className="card-body p-6">
        <div className="flex items-center gap-3 mb-3">
          <div className="w-12 h-12 rounded-full bg-primary/20 flex items-center justify-center">
            <Mic className="w-6 h-6 text-primary" />
          </div>
          <div className="flex-1">
            <h3 className="card-title text-base">{episode.title}</h3>
            <p className="text-sm text-base-content/60">{episode.source}</p>
          </div>
        </div>
        <p className="text-sm text-base-content/80 line-clamp-3">{episode.summary}</p>
      </div>
    </div>
  );
}

// components/variants/episode-card-v3.tsx - List-style version
export function EpisodeCardV3({ episode }: EpisodeCardProps) {
  return (
    <div className="flex items-center gap-4 p-4 hover:bg-base-200/50 rounded-lg transition-colors">
      <div className="w-2 h-12 bg-primary rounded-full flex-shrink-0" />
      <div className="flex-1 min-w-0">
        <h3 className="font-medium text-sm truncate">{episode.title}</h3>
        <p className="text-xs text-base-content/60 line-clamp-1">{episode.summary}</p>
      </div>
      <PlayButton size="sm" />
    </div>
  );
}
```

3. **Use composition over inheritance**:
```tsx
export function EpisodePlayer({ episode, isLoading, onPlay, variant = 'minimal' }: EpisodePlayerProps) {
  const CardComponent = {
    minimal: EpisodeCardV1,
    detailed: EpisodeCardV2,
    compact: EpisodeCardV3
  }[variant];

  return (
    <CardComponent episode={episode} onPlay={onPlay} isLoading={isLoading} />
  );
}
```

4. **Include all component states**:
   - Loading state
   - Error state
   - Empty state
   - Success state

### Sleek UI Design Principles
- **Minimalism**: Clean layouts with purposeful whitespace
- **Consistency**: Unified spacing, typography, and color schemes
- **Performance**: Smooth animations under 300ms, optimized rendering
- **Modern Aesthetics**: Subtle shadows, rounded corners, contemporary patterns
- **Accessibility**: Proper contrast ratios, keyboard navigation, semantic HTML

### Styling Standards
- Use Tailwind utility classes primarily
- Leverage DaisyUI themes and components for consistency
- Follow mobile-first responsive design
- Implement dark mode support with DaisyUI themes
- Use Radix UI for complex interactions (dialogs, dropdowns, etc.)
- Add subtle animations with Framer Motion
- **STRONGLY prefer Tailwind classes over inline styles** - use Tailwind's theme-aware classes (e.g., `bg-base-100`, `text-base-content`) that automatically adapt to DaisyUI themes
- **AVOID global CSS overrides** unless absolutely necessary - prefer Tailwind classes for easier migrations/updates
- When styling fixes are needed, use component-level Tailwind classes before considering inline styles or globals.css

### State Management
- **Local state**: React useState/useReducer
- **Server state**: tRPC queries and mutations
- **Form state**: React Hook Form with Zod validation
- **Global state**: React Context (minimal usage)

### Bun-Specific Development
- Use `bun install` instead of `npm install`
- Run scripts with `bun run <script>`
- Use `bun test` for component testing
- Leverage Bun's fast hot reload during development
- Take advantage of built-in TypeScript support

### Mock Data Strategy
Create comprehensive mock data that matches your planned backend structure:

```typescript
// lib/mock-data/episodes.ts
export const mockEpisodes: Episode[] = [
  {
    id: 'ep-1',
    sourceId: 'tldr',
    title: 'TLDR Tech News - January 4th',
    summary: 'Today in tech: OpenAI announces new features...',
    audioUrl: null,
    status: 'generating',
    // ... all other fields
  }
];

// lib/mock-data/component-variants.ts
export const variantConfigs = {
  episodeCard: {
    variants: ['minimal', 'detailed', 'compact'],
    default: 'minimal'
  },
  player: {
    variants: ['traditional', 'spotify', 'waveform'],
    default: 'traditional'
  }
};
```

## Task Management Workflow

### Branch Naming Convention
- `feat/foundation-setup`
- `feat/core-components`
- `feat/ui-variants`
- `feat/data-layer`
- `feat/audio-pipeline`
- `feat/queue-system`
- `feat/ux-polish`
- `feat/production-ready`

### PR Creation Rules
- Create a new PR for each major task
- **Include screenshots or GIFs of ALL component variants**
- Write clear commit messages
- Test components with different states and variants
- Ensure TypeScript compilation passes
- Document which variant performs best and why

### Development Phases
1. **Foundation**: Set up project structure with Bun and basic components
2. **Components**: Build all UI components with multiple variants using mock data
3. **Selection**: Test and select best-performing component variants
4. **Data Layer**: Add database schema and API endpoints
5. **Services**: Implement AI and audio generation services
6. **Integration**: Connect frontend to backend
7. **Polish**: Add animations, responsive design, and UX improvements
8. **Production**: Deployment and monitoring

### Component Variant Selection Process
1. **Build 2-3 versions** of each key component
2. **Create comparison page** showing all variants side by side
3. **Test with different data states** (loading, error, empty, full)
4. **Evaluate performance and UX** of each variant
5. **Select winner** or combine best elements
6. **Implement chosen design** across the app
7. **Document decision rationale**

## Code Quality Standards

### TypeScript
- Use strict mode
- Define interfaces for all data structures
- Avoid `any` type
- Use type guards for runtime validation
- Include variant types in component interfaces

### Components
- Keep components small and focused
- Use meaningful prop names
- Include JSDoc comments for complex components
- Export component types
- Support variant prop when applicable

### Error Handling
- Always handle loading states
- Provide meaningful error messages
- Use try-catch for async operations
- Implement retry mechanisms where appropriate

### Performance
- Use React.memo for expensive components
- Implement proper key props for lists
- Lazy load heavy components
- Optimize images and assets
- Leverage Bun's fast bundling

## AI Agent Instructions

### When Working on Components
1. **Always ask for clarification** on component requirements and variant needs
2. **Show multiple implementation options** when building key UI components
3. **Include accessibility features** (ARIA labels, keyboard navigation)
4. **Provide complete, working code** - not just snippets
5. **Test with different data scenarios** (empty, loading, error states)
6. **Create sleek, modern designs** that feel fast and intuitive
7. **Build 2-3 variants** for important components when use cases permit

### When Working on UI Variants
1. **Explain the design philosophy** behind each variant
2. **Show clear visual differences** between versions
3. **Consider different use cases** (mobile vs desktop, different content lengths)
4. **Provide implementation for easy switching** between variants
5. **Document pros and cons** of each approach

### When Working on APIs
1. **Start with tRPC procedure definition**
2. **Include Zod schema validation**
3. **Add proper error handling**
4. **Consider rate limiting and caching**
5. **Write clear API documentation**

### When Working with Bun
1. **Use Bun commands** in all scripts and examples
2. **Leverage Bun's speed** for fast iteration
3. **Use Bun's test runner** for component testing
4. **Take advantage of built-in TypeScript** support

### When Working with External Libraries
1. **Use Context7 MCP** when working with open source libraries and external dependencies
2. **Use Playwright MCP** to assist with development, testing, and UI validation
3. **Leverage browser automation** for component testing and visual validation
4. **Use web scraping capabilities** for testing real-world integrations

### Git Workflow & Branching Strategy
1. **Create new branch after commits and before starting new tasks**:
   - After completing a task and committing changes, create a new branch
   - Use descriptive branch names: `feat/feature-flags`, `fix/posthog-client-issue`, `refactor/component-structure`
   - Branch from main unless continuing related work
   - Example workflow:
     ```bash
     git add .
     git commit -m "feat: implement feature flag infrastructure"
     git checkout -b feat/visual-regression-testing  # New branch for next task
     ```

2. **Make commits between subtasks** for granular progress tracking

3. **Use conventional commit messages** (enforced by commitlint):
   - `feat:` for new features
   - `fix:` for bug fixes
   - `docs:` for documentation only changes
   - `style:` for formatting/whitespace changes
   - `refactor:` for code changes that neither fix bugs nor add features
   - `perf:` for performance improvements
   - `test:` for adding/correcting tests
   - `chore:` for build process/auxiliary tool changes
   - `ci:` for CI configuration changes
   - `build:` for build system/dependency changes
   - `revert:` for reverting previous commits

4. **Include scope when applicable**: `feat(components): add button variants`

5. **Write clear, descriptive commit messages** that explain the "what" and "why"

6. **Commit frequently** to maintain a clean development history

7. **Commitlint enforces**:
   - Maximum header length: 100 characters
   - No capitalized subjects (except proper nouns)
   - No period at end of subject
   - Required type and subject

8. **Branch Management Best Practices**:
   - Keep branches focused on single features/fixes
   - Merge branches back to main when complete
   - Delete merged branches to keep repository clean
   - Use descriptive branch names that match the task being worked on

### Code Quality & Standards
1. **ESLint**: Configured with TypeScript, React, and import rules
2. **Prettier**: Automatic code formatting on commit
3. **Husky**: Git hooks for quality checks
   - **Pre-commit**: Runs lint-staged (linting + formatting on staged files)
   - **Pre-push**: Runs type checking and linting on entire codebase
   - **Commit-msg**: Runs commitlint to enforce conventional commit messages
4. **TypeScript**: Strict type checking with `tsc --noEmit`
5. **Commitlint**: Enforces conventional commit message format

## Setup & Development Plan

### Updated Tech Stack

#### Core Framework
- **Next.js 15** with App Router and TypeScript
- **Tailwind CSS 4** for styling
- **DaisyUI** for component primitives
- **Radix UI** for advanced components
- **Framer Motion** for animations
- **Bun** as package manager and runtime (fast installs, hot reload, built-in testing)

#### Database & API
- **Vercel Postgres** with **Drizzle ORM**
- **tRPC** for type-safe APIs
- **Zod 4** for schema validation

#### External Services
- **OpenAI and Claude** (GPT-4 + TTS)
- **Vercel Blob** for audio storage

### Initial Setup Commands

```bash
# Create Next.js 15 app with Bun
bunx create-next-app@latest podcast-generator --typescript --tailwind --eslint --app

cd podcast-generator

# Install core dependencies with Bun
bun add @tailwindcss/typography daisyui
bun add @radix-ui/react-dialog @radix-ui/react-progress @radix-ui/react-select
bun add @radix-ui/react-slider @radix-ui/react-toast @radix-ui/react-dropdown-menu
bun add framer-motion lucide-react

# Database & API
bun add drizzle-orm @vercel/postgres drizzle-kit
bun add @trpc/server @trpc/client @trpc/next @trpc/react-query
bun add @tanstack/react-query zod

# Audio & AI services
bun add openai @vercel/blob

# Development dependencies
bun add -d @types/node

# Scripts in package.json should use bun
# "dev": "bun run next dev"
# "build": "bun run next build"
# "start": "bun run next start"
```

### Project Structure

```
/
├── app/
│   ├── globals.css
│   ├── layout.tsx
│   ├── page.tsx
│   ├── api/
│   │   └── trpc/[trpc]/route.ts
│   └── episodes/
│       └── [id]/page.tsx
├── components/
│   ├── ui/           # Radix + DaisyUI base components
│   │   ├── button.tsx
│   │   ├── progress.tsx
│   │   ├── dialog.tsx
│   │   └── select.tsx
│   ├── features/     # App-specific components
│   │   ├── episode-player.tsx
│   │   ├── source-selector.tsx
│   │   ├── queue-status.tsx
│   │   └── episode-card.tsx
│   ├── variants/     # Multiple UI versions for A/B testing
│   │   ├── episode-card-v1.tsx
│   │   ├── episode-card-v2.tsx
│   │   └── episode-card-v3.tsx
│   └── layouts/      # Page layouts
│       ├── main-layout.tsx
│       └── player-layout.tsx
├── lib/
│   ├── db/
│   │   ├── schema.ts
│   │   └── connection.ts
│   ├── trpc/
│   │   ├── client.ts
│   │   ├── server.ts
│   │   └── routers/
│   ├── services/
│   ├── schemas/
│   ├── utils/
│   └── mock-data/    # Mock data for development
├── types/
│   └── index.ts
└── tailwind.config.js
```

### Development Tasks & Subtasks

#### Phase 1: Foundation Setup
**Branch: `feat/foundation-setup`**

##### Task 1.1: Project Initialization
- [ ] Create Next.js 15 project with TypeScript and Bun
- [ ] Install and configure Tailwind CSS 4
- [ ] Set up DaisyUI configuration
- [ ] Install Radix UI components
- [ ] Configure ESLint and Prettier for Bun
- [ ] Set up basic folder structure
- [ ] Configure package.json scripts to use Bun

##### Task 1.2: UI Component Library
- [ ] Create base Button component (Radix + DaisyUI)
- [ ] Create Progress component
- [ ] Create Dialog/Modal component
- [ ] Create Select/Dropdown component
- [ ] Create Slider component for audio controls
- [ ] Create Toast notification component
- [ ] Set up component documentation/Storybook (optional)

##### Task 1.3: Layout System
- [ ] Create MainLayout component with navigation
- [ ] Create PlayerLayout for episode pages
- [ ] Set up responsive navigation with mobile menu
- [ ] Add dark/light mode toggle
- [ ] Create footer component

#### Phase 2: Core Features - Component First (Sleek UI Focus)
**Branch: `feat/core-components`**

> **UI Design Philosophy**: Build simple, sleek, and modern interfaces that feel fast and intuitive. When possible, create 2-3 different versions of key components to compare and select the best approach.

##### Task 2.1: Episode Components (Multiple Versions)
- [ ] **EpisodeCard Component Variants**:
  - [ ] Version 1: Minimal card with clean typography
  - [ ] Version 2: Visual-heavy with large thumbnails
  - [ ] Version 3: Compact list-style layout
- [ ] **EpisodePlayer Component Variants**:
  - [ ] Version 1: Traditional player controls
  - [ ] Version 2: Spotify-inspired design
  - [ ] Version 3: Minimalist waveform player
- [ ] Create EpisodeList component with grid/list toggle
- [ ] Add smooth loading states and skeleton screens
- [ ] Create elegant empty states with micro-interactions

##### Task 2.2: Source Selection Components (Sleek Design)
- [ ] **SourceCard Component Variants**:
  - [ ] Version 1: Clean card with status indicators
  - [ ] Version 2: Badge-style compact design
  - [ ] Version 3: Interactive tile with hover effects
- [ ] Create SourceSelector grid with smooth animations
- [ ] Build SourceFilter with slide-in panels
- [ ] Add subtle status indicators with color coding
- [ ] Create generation trigger with progress feedback

##### Task 2.3: Queue & Status Components (Real-time Feel)
- [ ] **QueueStatus Component Variants**:
  - [ ] Version 1: Progress bar with step indicators
  - [ ] Version 2: Circular progress with animations
  - [ ] Version 3: Timeline-style queue visualization
- [ ] Create GenerationProgress with smooth transitions
- [ ] Build QueuePosition with live updates
- [ ] Add StatusBadge with color transitions
- [ ] Implement real-time status animations with Framer Motion

#### Phase 3: Data Layer Setup
**Branch: `feat/data-layer`**

##### Task 3.1: Database Schema
- [ ] Set up Drizzle ORM configuration with Bun
- [ ] Create database schema (episodes, sources, queue, etc.)
- [ ] Set up database migrations
- [ ] Create seed data script (runnable with `bun run seed`)
- [ ] Set up Vercel Postgres connection

##### Task 3.2: tRPC API Setup
- [ ] Configure tRPC server and client
- [ ] Create episodes router
- [ ] Create sources router
- [ ] Create queue router
- [ ] Add input validation with Zod
- [ ] Set up API error handling

##### Task 3.3: Mock Data Integration
- [ ] Create comprehensive mock data
- [ ] Connect components to mock data
- [ ] Test all component variants with mock data
- [ ] Create data loading patterns
- [ ] Add optimistic updates

#### Phase 4: Audio Generation Pipeline
**Branch: `feat/audio-pipeline`**

##### Task 4.1: Content Scraping Service
- [ ] Create base scraper interface
- [ ] Implement TLDR scraper
- [ ] Implement Hacker News scraper
- [ ] Implement Morning Brew scraper
- [ ] Add content deduplication
- [ ] Create scraping scheduler with Bun cron

##### Task 4.2: AI Summarization
- [ ] Set up OpenAI integration
- [ ] Create summarization service
- [ ] Add content optimization for TTS
- [ ] Create summary quality validation
- [ ] Add cost tracking

##### Task 4.3: Text-to-Speech Integration
- [ ] Implement OpenAI TTS service
- [ ] Add Google Cloud TTS as backup
- [ ] Create audio file management
- [ ] Set up Vercel Blob storage
- [ ] Add audio caching logic

#### Phase 5: Queue System & Background Jobs
**Branch: `feat/queue-system`**

##### Task 5.1: Generation Queue
- [ ] Create queue processing service with Bun
- [ ] Implement priority-based processing
- [ ] Add concurrent job limiting
- [ ] Create queue monitoring dashboard
- [ ] Add job retry logic

##### Task 5.2: Real-time Updates
- [ ] Set up polling for queue status
- [ ] Add WebSocket support (optional)
- [ ] Create real-time progress indicators
- [ ] Add notification system
- [ ] Test queue edge cases

#### Phase 6: User Experience & Polish
**Branch: `feat/ux-polish`**

##### Task 6.1: Component Selection & Refinement
- [ ] **A/B Test Component Variants**:
  - [ ] Create comparison page for episode card variants
  - [ ] Test player component versions
  - [ ] Evaluate queue status variants
  - [ ] Select best-performing designs
- [ ] Implement chosen components across the app
- [ ] Add consistent micro-interactions
- [ ] Polish animations and transitions

##### Task 6.2: Audio Player Enhancement
- [ ] Add playback controls (play/pause, seek)
- [ ] Implement playback speed control
- [ ] Add volume control
- [ ] Create playlist functionality
- [ ] Add keyboard shortcuts

##### Task 6.3: Responsive Design
- [ ] Optimize for mobile devices
- [ ] Test tablet layouts
- [ ] Add touch gestures for player
- [ ] Optimize loading performance with Bun
- [ ] Add PWA capabilities

##### Task 6.4: Analytics & Monitoring
- [ ] Add play count tracking
- [ ] Implement cost monitoring
- [ ] Create usage analytics
- [ ] Add error tracking
- [ ] Set up performance monitoring

#### Phase 7: Deployment & Production
**Branch: `feat/production-ready`**

##### Task 7.1: Production Configuration
- [ ] Set up environment variables
- [ ] Configure production database
- [ ] Set up Vercel deployment with Bun
- [ ] Add health check endpoints
- [ ] Configure monitoring alerts

##### Task 7.2: Testing & Quality
- [ ] Add component tests (run with `bun test`)
- [ ] Add API integration tests
- [ ] Test error scenarios
- [ ] Performance testing
- [ ] Security audit

#### Phase 8: Feature Flagging & Experimentation
**Branch: `feat/feature-flags`**

##### Task 8.1: Feature Flag Infrastructure Setup
- [ ] Research and select feature flagging solution (PostHog vs Vercel Edge Config)
- [ ] Set up feature flag environment configuration
- [ ] Create feature flag management dashboard
- [ ] Implement basic feature flag middleware
- [ ] Add feature flag types and interfaces

##### Task 8.2: Feature Flag Implementation
- [ ] Create feature flag hook (`useFeatureFlag`)
- [ ] Implement feature flag provider component
- [ ] Add feature flag utilities (flag evaluation, fallbacks)
- [ ] Create server-side feature flag evaluation
- [ ] Set up feature flag caching strategy

##### Task 8.3: A/B Testing & Experimentation Framework
- [ ] Implement user segmentation logic
- [ ] Create experiment tracking system
- [ ] Add analytics integration for experiments
- [ ] Build experiment results dashboard
- [ ] Set up automated experiment lifecycle management

##### Task 8.4: Feature Flag Integration
- [ ] Flag new podcast generation features
- [ ] Add feature toggles for UI components
- [ ] Implement gradual rollout for new sources
- [ ] Flag experimental AI summarization models
- [ ] Add feature flags for performance optimizations

##### Task 8.5: Monitoring & Analytics
- [ ] Set up feature flag usage tracking
- [ ] Monitor flag performance impact
- [ ] Create alerting for flag-related issues
- [ ] Build feature flag audit logging
- [ ] Implement automated flag cleanup for expired experiments

**Feature Flagging Strategy Questions:**

1. **Which platform should we prioritize?**
   - PostHog (free tier: 1M feature flag requests/month, full analytics integration)
   - Vercel Edge Config (free tier: 500KB storage, 200K reads/month)
   - Custom solution with database storage
   - Hybrid approach (PostHog for experiments, Edge Config for operational flags)

2. **What types of feature flags do we need?**
   - **Release toggles**: New features in development
   - **Experiment toggles**: A/B testing variations
   - **Ops toggles**: Circuit breakers and performance controls
   - **Permission toggles**: User/role-based feature access

3. **How should we handle flag evaluation?**
   - Client-side only (faster, less secure)
   - Server-side only (more secure, slower)
   - Hybrid approach (cached client-side with server validation)
   - Edge evaluation (Vercel Edge Functions)

4. **What's our experimentation strategy?**
   - Component-level A/B testing (episode card variants)
   - Feature-level experiments (new AI models)
   - User experience experiments (navigation changes)
   - Performance experiments (different caching strategies)

5. **How do we ensure flag hygiene?**
   - Automated flag lifecycle management
   - Regular flag cleanup schedules
   - Flag dependency tracking
   - Documentation requirements for new flags

**Recommended Approach:**
Based on research, **PostHog** offers the best value for our use case:

**✅ PostHog Advantages:**
- **Free tier**: 1M feature flag requests/month (plenty for our scale)
- **Full analytics integration**: Track experiment results seamlessly
- **Session replay integration**: See how flags affect user behavior
- **Advanced targeting**: User properties, cohorts, geographic targeting
- **Multi-environment support**: Development, staging, production flags
- **API access**: Programmatic flag management
- **No vendor lock-in**: Open source with self-hosting option

**Implementation Priority:**
1. Start with PostHog for comprehensive solution
2. Implement essential flags for new features
3. Set up A/B testing for component variants
4. Add performance monitoring for flag evaluation
5. Consider Edge Config for high-frequency operational toggles if needed

### UI Design Principles

#### Sleek Design Guidelines
1. **Minimalism**: Use whitespace effectively, avoid clutter
2. **Consistency**: Maintain consistent spacing, typography, and color schemes
3. **Performance**: Smooth animations, fast loading, responsive interactions
4. **Accessibility**: Proper contrast, keyboard navigation, screen reader support
5. **Modern Aesthetics**: Contemporary design patterns, subtle shadows, rounded corners

#### Component Variant Strategy
When building key UI components, create multiple versions to:
- **Compare different approaches** (minimal vs. detailed)
- **Test user preferences** (through A/B testing)
- **Iterate quickly** (select best elements from each version)
- **Learn what works** (build design system knowledge)

#### Animation Guidelines
- Use Framer Motion for smooth, purposeful animations
- Keep animations under 300ms for UI feedback
- Add subtle hover effects and loading states
- Implement page transitions for better UX
- Use easing curves that feel natural

### Mock Data Structure

```typescript
// lib/mock-data/episodes.ts
export const mockEpisodes = [
  {
    id: 'ep-1',
    sourceId: 'tldr',
    title: 'TLDR Tech News - January 4th',
    summary: 'Today in tech: OpenAI announces new features, Apple releases iOS update, and more...',
    contentHash: 'abc123',
    audioUrl: null,
    audioSize: null,
    playCount: 0,
    generationCost: 0.15,
    ttsService: 'openai',
    createdAt: new Date(),
    updatedAt: new Date(),
  },
  // ... more mock episodes
];

// lib/mock-data/sources.ts
export const mockSources = [
  {
    id: 'tldr',
    name: 'TLDR Newsletter',
    url: 'https://tldr.tech',
    ttsService: 'openai',
    dailyLimit: 3,
    contentTier: 'premium',
    active: true,
  },
  // ... more mock sources
];
```

### Bun-Specific Configurations

#### Package.json Scripts
```json
{
  "scripts": {
    "dev": "bun run next dev --turbopack",
    "build": "bun run next build",
    "start": "bun run next start",
    "lint": "bun run next lint",
    "db:generate": "bun run drizzle-kit generate:pg",
    "db:migrate": "bun run drizzle-kit push:pg",
    "db:seed": "bun run scripts/seed.ts",
    "test": "bun test",
    "lint:check": "bun run lint",
    "lint:fix": "bun run lint --fix",
    "format:check": "prettier --check .",
    "format": "prettier --write .",
    "type-check": "tsc --noEmit",
    "update": "bun update",
    "update:interactive": "bun update --interactive",
    "outdated": "bun outdated",
    "clean": "rm -rf node_modules bun.lockb && bun install"
  }
}
```

#### Bun Test Configuration
```typescript
// bun.config.ts
export default {
  test: {
    root: "./tests",
  },
};
```

### Component Development Standards

#### Component Structure
```tsx
interface ComponentProps {
  // Define props with TypeScript
  variant?: 'v1' | 'v2' | 'v3'; // For multiple versions
}

export function Component({ prop1, prop2, variant = 'v1' }: ComponentProps) {
  // Component logic with variant handling
  
  return (
    <div className="tailwind-classes">
      {/* Component JSX with conditional rendering for variants */}
    </div>
  );
}
```

#### Styling Guidelines
- Use Tailwind utility classes for consistency
- Leverage DaisyUI components for base elements
- Use Radix UI for complex interactions
- Follow mobile-first responsive design
- Implement dark mode support with DaisyUI themes
- Create sleek, modern interfaces with subtle animations

#### State Management
- Use React state for component-level state
- Use tRPC for server state
- Implement optimistic updates
- Add proper loading and error states
- Consider component variants in state management

### Git Workflow & Review Process

**IMPORTANT: Review-Before-Commit Workflow**
- **Always pause for user review** before making any commits
- Present changes clearly to user for validation
- User must approve changes before committing
- Only commit after explicit user approval
- Ask for commit confirmation before proceeding to next task

**Standard Git Workflow:**
1. Create feature branch from main
2. Implement task/subtasks
3. Build multiple component versions when applicable
4. Test components in isolation
5. **PAUSE: Present changes to user for review**
6. **WAIT: Get user approval before committing**
7. Commit with descriptive message after approval
8. **CREATE NEW BRANCH before starting next task** (e.g., `git checkout -b feat/next-feature`)
9. Create PR with screenshots/demos of different variants
10. Review and select preferred designs
11. Merge and move to next task

**Branching Strategy:**
- **Always create a new branch after commits and before starting new tasks**
- Use descriptive branch names: `feat/feature-flags`, `fix/posthog-client-issue`, `refactor/component-structure`
- Branch from main unless continuing related work
- Example workflow:
  ```bash
  git add .
  git commit -m "feat: implement feature flag infrastructure"
  git checkout -b feat/visual-regression-testing  # New branch for next task
  ```

**Commit Process:**
- Always describe what was changed and why
- Include file changes summary
- Wait for user confirmation before executing commit
- Use semantic commit messages (feat:, fix:, chore:, etc.)

**File Structure Maintenance:**
- **REQUIRED**: Update the "Current Codebase Structure" section whenever:
  - Creating new files or folders
  - Deleting files or folders  
  - Moving or renaming files or folders
  - This prevents getting lost in the codebase and helps with navigation

### Success Criteria

Each phase should result in:
- Working, tested components (with variants when applicable)
- Proper TypeScript coverage
- Responsive, sleek design
- Accessible components
- Performance optimized (leveraging Bun's speed)
- Clear documentation
- Git history with meaningful commits

### Development Environment
- Use Bun for all package management and script execution
- Leverage Bun's fast hot reload during development
- Use Bun's built-in test runner for component testing
- Take advantage of Bun's TypeScript support for faster builds

## Common Patterns

### Loading States (Sleek Design)
```tsx
{isLoading ? (
  <div className="animate-pulse">
    <div className="h-4 bg-base-300/50 rounded-lg w-full mb-2"></div>
    <div className="h-3 bg-base-300/30 rounded-lg w-3/4"></div>
  </div>
) : (
  <div>{content}</div>
)}
```

### Error Handling (User-Friendly)
```tsx
{error ? (
  <div className="alert alert-error shadow-lg">
    <div>
      <AlertCircle className="w-5 h-5" />
      <span className="font-medium">{error.message}</span>
    </div>
  </div>
) : (
  <div>{content}</div>
)}
```

### Variant Switching
```tsx
const VariantComponents = {
  v1: ComponentV1,
  v2: ComponentV2,
  v3: ComponentV3
} as const;

const Component = VariantComponents[variant] || VariantComponents.v1;
return <Component {...props} />;
```

### Form Validation
```tsx
const schema = z.object({
  title: z.string().min(1, 'Title is required'),
  sourceId: z.string().min(1, 'Source is required'),
});

const form = useForm<z.infer<typeof schema>>({
  resolver: zodResolver(schema),
});
```

## Testing Strategy
- **Component testing**: Test individual components and variants with `bun test`
- **Variant testing**: Test all component variants with different props
- **Integration testing**: Test component interactions
- **API testing**: Test tRPC procedures
- **E2E testing**: Test complete user flows
- **Performance testing**: Measure component render times

## Deployment Checklist
- [ ] Environment variables configured
- [ ] Database migrations run
- [ ] Build passes without errors (using Bun)
- [ ] API endpoints tested
- [ ] All component variants tested
- [ ] Performance optimized
- [ ] Error monitoring set up
- [ ] Selected component variants documented

## Resources
- [Next.js 15 Documentation](https://nextjs.org/docs)
- [Bun Documentation](https://bun.sh/docs)
- [Tailwind CSS 4 Documentation](https://tailwindcss.com/docs)
- [DaisyUI Components](https://daisyui.com/components/)
- [Radix UI Documentation](https://www.radix-ui.com/docs)
- [Framer Motion Documentation](https://www.framer.com/motion/)
- [tRPC Documentation](https://trpc.io/docs)
- [Drizzle ORM Documentation](https://orm.drizzle.team/docs)

## Bun Quick Reference
```bash
# Package management
bun install                    # Install dependencies
bun add <package>             # Add dependency
bun add -d <package>          # Add dev dependency
bun remove <package>          # Remove dependency

# Package updates
bun update                    # Update all dependencies
bun update:interactive        # Interactive dependency updates
bun outdated                  # Check for outdated packages
bun clean                     # Clean install (remove node_modules & lockfile)

# Running scripts
bun run dev                   # Start development server
bun run build                 # Build for production
bun run test                  # Run tests
bun run db:seed               # Run database seeding

# Code quality
bun run lint:check            # Check for linting errors
bun run lint:fix              # Fix linting errors automatically
bun run format:check          # Check code formatting
bun run format                # Format code with Prettier
bun run type-check            # TypeScript type checking

# Testing
bun test                      # Run all tests
bun test <file>               # Run specific test file
bun test --watch              # Run tests in watch mode

# Node.js version management
nvm use                       # Use Node.js version from .nvmrc (22)
```

Remember: The goal is to build working, tested components with multiple sleek variants that can be easily compared, selected, and composed. Focus on creating modern, intuitive user experiences while leveraging Bun's speed for rapid iteration. 